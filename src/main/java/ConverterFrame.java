
import java.util.*;

/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template
 */

/**
 *
 * @author Dev Gerald
 */
public class ConverterFrame extends javax.swing.JFrame {

    /**
     * Creates new form ConverterFrame
     */
    public ConverterFrame() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        entryPanel = new javax.swing.JPanel();
        enterLabel = new javax.swing.JLabel();
        entryTextField = new javax.swing.JTextField();
        convertButton = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        convertionPanel = new javax.swing.JPanel();
        infixLabel = new javax.swing.JLabel();
        prefixLabel = new javax.swing.JLabel();
        postfixLabel = new javax.swing.JLabel();
        infixTextField = new javax.swing.JTextField();
        prefixTextField = new javax.swing.JTextField();
        postfixTextField = new javax.swing.JTextField();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Notation Converter");

        enterLabel.setFont(new java.awt.Font("Segoe UI", 0, 16)); // NOI18N
        enterLabel.setText("Enter:");

        entryTextField.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                entryTextFieldActionPerformed(evt);
            }
        });

        convertButton.setFont(new java.awt.Font("Segoe UI", 0, 16)); // NOI18N
        convertButton.setText("Convert");
        convertButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                convertButtonActionPerformed(evt);
            }
        });

        jLabel1.setForeground(new java.awt.Color(255, 102, 0));
        jLabel1.setText("Warning: Do not put white spaces");

        javax.swing.GroupLayout entryPanelLayout = new javax.swing.GroupLayout(entryPanel);
        entryPanel.setLayout(entryPanelLayout);
        entryPanelLayout.setHorizontalGroup(
            entryPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(entryPanelLayout.createSequentialGroup()
                .addGap(15, 15, 15)
                .addComponent(enterLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 57, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(entryPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(entryPanelLayout.createSequentialGroup()
                        .addComponent(entryTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 265, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(convertButton))
                    .addComponent(jLabel1))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        entryPanelLayout.setVerticalGroup(
            entryPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(entryPanelLayout.createSequentialGroup()
                .addGap(24, 24, 24)
                .addGroup(entryPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(enterLabel)
                    .addComponent(entryTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 39, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(convertButton))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel1)
                .addContainerGap(9, Short.MAX_VALUE))
        );

        infixLabel.setFont(new java.awt.Font("Segoe UI", 0, 16)); // NOI18N
        infixLabel.setText("Infix:");

        prefixLabel.setFont(new java.awt.Font("Segoe UI", 0, 16)); // NOI18N
        prefixLabel.setText("Prefix:");

        postfixLabel.setFont(new java.awt.Font("Segoe UI", 0, 16)); // NOI18N
        postfixLabel.setText("Postfix:");

        infixTextField.setEditable(false);
        infixTextField.setBackground(new java.awt.Color(204, 255, 204));
        infixTextField.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                infixTextFieldActionPerformed(evt);
            }
        });

        prefixTextField.setEditable(false);
        prefixTextField.setBackground(new java.awt.Color(204, 255, 204));
        prefixTextField.setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));

        postfixTextField.setEditable(false);
        postfixTextField.setBackground(new java.awt.Color(204, 255, 204));
        postfixTextField.setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));

        javax.swing.GroupLayout convertionPanelLayout = new javax.swing.GroupLayout(convertionPanel);
        convertionPanel.setLayout(convertionPanelLayout);
        convertionPanelLayout.setHorizontalGroup(
            convertionPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(convertionPanelLayout.createSequentialGroup()
                .addGroup(convertionPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(convertionPanelLayout.createSequentialGroup()
                        .addGap(14, 14, 14)
                        .addComponent(infixLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 47, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, convertionPanelLayout.createSequentialGroup()
                        .addContainerGap()
                        .addGroup(convertionPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(prefixLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 47, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(postfixLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 57, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(10, 10, 10)))
                .addGroup(convertionPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(postfixTextField)
                    .addComponent(prefixTextField)
                    .addComponent(infixTextField, javax.swing.GroupLayout.Alignment.TRAILING))
                .addContainerGap())
        );
        convertionPanelLayout.setVerticalGroup(
            convertionPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(convertionPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(convertionPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(infixTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 47, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(infixLabel))
                .addGap(18, 18, 18)
                .addGroup(convertionPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(prefixTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 45, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(prefixLabel))
                .addGap(18, 18, 18)
                .addGroup(convertionPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(postfixTextField, javax.swing.GroupLayout.DEFAULT_SIZE, 46, Short.MAX_VALUE)
                    .addComponent(postfixLabel))
                .addContainerGap())
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(entryPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addComponent(convertionPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(entryPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(convertionPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        entryPanel.getAccessibleContext().setAccessibleName("");
        entryPanel.getAccessibleContext().setAccessibleDescription("");

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void convertButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_convertButtonActionPerformed
        // TODO add your handling code here:
        if(isPrefix(entryTextField.getText())){
            // To display prefix
            prefixTextField.setText(entryTextField.getText());
            //To display infix of the given prefix
            infixTextField.setText(prefixToInfix(entryTextField.getText()));
            //To display postfix version of the given prefix
            postfixTextField.setText(prefixToPostfix(entryTextField.getText()));
        } else if(isPostfix(entryTextField.getText())){
            // To display postfix
            postfixTextField.setText(entryTextField.getText());
            //To display infix of the given postfix
            infixTextField.setText(postfixToInfix(entryTextField.getText()));
            // To display prefix version of the given postfix
            prefixTextField.setText(postfixToPrefix(entryTextField.getText()));
        }
        else {
            //Not prefix or postfix means infix
            //To display the same infix inside the infix field
            infixTextField.setText("(" + entryTextField.getText() + ")");
            // To display prefix version of the given infix
            prefixTextField.setText(infixToPrefix(entryTextField.getText()).toString());
            //To display postfix version of the given infix
            postfixTextField.setText(infixToPostfix(entryTextField.getText()));
        }
    }//GEN-LAST:event_convertButtonActionPerformed

    private void infixTextFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_infixTextFieldActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_infixTextFieldActionPerformed

    private void entryTextFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_entryTextFieldActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_entryTextFieldActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(ConverterFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(ConverterFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(ConverterFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(ConverterFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new ConverterFrame().setVisible(true);
            }
        });
    }
        
    // To check if expression entered is prefix
    public static boolean isPrefix(String expression) {
        Stack<Integer> stack = new Stack<Integer>();
        for (int i = expression.length() - 1; i >= 0; i--) {
            char c = expression.charAt(i);
            if (Character.isLetterOrDigit(c)) {
                stack.push(c - '0');
            } else {
                if (stack.size() < 2) {
                    return false;
                }
                int op1 = stack.pop();
                int op2 = stack.pop();
                stack.push(compute(c, op1, op2));
            }
        }
        return stack.size() == 1;
    }

    // To check if expression entered is postfix
    public static boolean isPostfix(String expression) {
        Stack<Integer> stack = new Stack<Integer>();
        for (int i = 0; i < expression.length(); i++) {
            char c = expression.charAt(i);
            if (Character.isLetterOrDigit(c)) {
                stack.push(c - '0');
            } else {
                if (stack.size() < 2) {
                    return false;
                }
                int op2 = stack.pop();
                int op1 = stack.pop();
                stack.push(compute(c, op1, op2));
            }
        }
        return stack.size() == 1;
    }
    
    // Use in finding what expression is entered
    private static int compute(char operator, int operand1, int operand2) {
        switch (operator) {
            case '+':
                return operand1 + operand2;
            case '-':
                return operand1 - operand2;
            case '*':
                return operand1 * operand2;
            case '/':
                return operand1 / operand2;
            case '%':
                return operand2 % operand1;
            case '^':
                return (int) Math.pow(operand1, operand2);
            default:
                throw new IllegalArgumentException("Unknown operator: " + operator);
        }
    }
        
    // To check precedence
    static int Prec(char ch)
    {
        switch (ch) {
        case '+':
        case '-':
            return 1;
 
        case '*':
        case '/':
            return 2;
 
        case '^':
            return 3;
        }
        return -1;
    }
    
    // To check if an operator or not.
    static boolean isOperator(char c)
    {
        switch(c) {
            case '+':
            case '-':
            case '*':
            case '/':
            case '^':
            case '%':
                return true;
        }
        return false;
    }
    
    // Function that converts infix to prefix
    static StringBuilder infixToPrefix(String expression){

        StringBuilder result = new StringBuilder();
        StringBuilder input = new StringBuilder(expression);
        input.reverse();
        Stack<Character> stack = new Stack<Character>();

        char [] charsExp = new String(input).toCharArray();
        for (int i = 0; i < charsExp.length; i++) {

            if (charsExp[i] == '(') {
                charsExp[i] = ')';
                i++;
            }
            else if (charsExp[i] == ')') {
                charsExp[i] = '(';
                i++;
            }
        }
        for (int i = 0; i < charsExp.length ; i++) {
            char c = charsExp[i];

            if(Prec(c)>0){
                while(stack.isEmpty()==false && Prec(stack.peek())>=Prec(c)){
                    result.append(stack.pop());
                }
                stack.push(c);
            }else if(c==')'){
                char x = stack.pop();
                while(x!='('){
                    result.append(x);
                    x = stack.pop();
                }
            }else if(c=='('){
                stack.push(c);
            }else{
                //character is neither operator nor “(“
                result.append(c);
            }
        }

        for (int i = 0; i <=stack.size() ; i++) {
            result.append(stack.pop());
        }
        return result.reverse();
    }
    
    //To convert infix to postfix
    static String infixToPostfix(String exp)
    {
        // initializing empty String for result
        String result = new String("");
 
        // initializing empty stack
        Deque<Character> stack
            = new ArrayDeque<Character>();
 
        for (int i = 0; i < exp.length(); ++i) {
            char c = exp.charAt(i);
 
            // If the scanned character is an
            // operand, add it to output.
            if (Character.isLetterOrDigit(c))
                result += c;
 
            // If the scanned character is an '(',
            // push it to the stack.
            else if (c == '(')
                stack.push(c);
 
            //  If the scanned character is an ')',
            // pop and output from the stack
            // until an '(' is encountered.
            else if (c == ')') {
                while (!stack.isEmpty()
                       && stack.peek() != '(') {
                    result += stack.peek();
                    stack.pop();
                }
 
                stack.pop();
            }
            else // an operator is encountered
            {
                while (!stack.isEmpty()
                       && Prec(c) <= Prec(stack.peek())) {
 
                    result += stack.peek();
                    stack.pop();
                }
                stack.push(c);
            }
        }
 
        // pop all the operators from the stack
        while (!stack.isEmpty()) {
            if (stack.peek() == '(')
                return "Invalid Expression";
            result += stack.peek();
            stack.pop();
        }
       
        return result;
    }
    
    //To convert prefix to infix
    public static String prefixToInfix(String str)
    {
        Stack<String> stack = new Stack<>();

        // Length of expression
        int l = str.length();

        // Reading from right to left
        for(int i = l - 1; i >= 0; i--)
        {
            char c = str.charAt(i);
            if (isOperator(c))
            {
                String op1 = stack.pop();
                String op2 = stack.pop();

                // Concat the operands and operator
                String temp = "(" + op1 + c + op2 + ")";
                stack.push(temp);
            }
            else
            {

                // To make character to string
                stack.push(c + "");
            }
        }
        return stack.pop();
    }
    
    //To convert prefix to postfix
        // Convert prefix to Postfix expression
    static String prefixToPostfix(String pre_exp)
    {
 
        Stack<String> s = new Stack<String>();
 
        // length of expression
        int length = pre_exp.length();
 
        // reading from right to left
        for (int i = length - 1; i >= 0; i--)
        {
            // check if symbol is operator
            if (isOperator(pre_exp.charAt(i)))
            {
                // pop two operands from stack
                String op1 = s.peek();
                s.pop();
                String op2 = s.peek();
                s.pop();
 
                // concat the operands and operator
                String temp = op1 + op2 + pre_exp.charAt(i);
 
                // Push String temp back to stack
                s.push(temp);
            }
 
            // if symbol is an operand
            else {
                // push the operand to the stack
                s.push(pre_exp.charAt(i) + "");
            }
        }
 
        // stack contains only the Postfix expression
        return s.peek();
    }
    
    // To convert postfix to infix
    static String postfixToInfix(String exp)
    {
        Stack<String> s = new Stack<String>();

        for (int i = 0; i < exp.length(); i++)
        {
            // Push operands
            if (!isOperator(exp.charAt(i)))
            {
            s.push(exp.charAt(i) + "");
            }

            // We assume that input is
            // a valid postfix and expect
            // an operator.
            else
            {
                String op1 = s.peek();
                s.pop();
                String op2 = s.peek();
                s.pop();
                s.push("(" + op2 + exp.charAt(i) +
                        op1 + ")");
            }
        }

        // There must be a single element
        // in stack now which is the required
        // infix.
        return s.peek();
    }
    
    // Convert postfix to Prefix expression
    static String postfixToPrefix(String post_exp)
    {
        Stack<String> s = new Stack<String>();
 
        // length of expression
        int length = post_exp.length();
 
        // reading from right to left
        for (int i = 0; i < length; i++) {
 
            // check if symbol is operator
            if (isOperator(post_exp.charAt(i))) {
 
                // pop two operands from stack
                String op1 = s.peek();
                s.pop();
                String op2 = s.peek();
                s.pop();
 
                // concat the operands and operator
                String temp
                    = post_exp.charAt(i) + op2 + op1;
 
                // Push String temp back to stack
                s.push(temp);
            }
 
            // if symbol is an operand
            else {
 
                // push the operand to the stack
                s.push(post_exp.charAt(i) + "");
            }
        }
 
        // concatenate all strings in stack and return the
        // answer
        String ans = "";
        for (String i : s)
            ans += i;
        return ans;
    }
    
  
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton convertButton;
    private javax.swing.JPanel convertionPanel;
    private javax.swing.JLabel enterLabel;
    private javax.swing.JPanel entryPanel;
    private javax.swing.JTextField entryTextField;
    private javax.swing.JLabel infixLabel;
    private javax.swing.JTextField infixTextField;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel postfixLabel;
    private javax.swing.JTextField postfixTextField;
    private javax.swing.JLabel prefixLabel;
    private javax.swing.JTextField prefixTextField;
    // End of variables declaration//GEN-END:variables
}
